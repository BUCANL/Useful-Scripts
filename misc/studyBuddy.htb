%% PERPARES INIT FOR BUCANL PIPE
    % This script takes either the raw files or a ESS study description XML,
    % that was loaded into the batch config, and transforms them into an init state
    % ready to enter the BUCANL ASR/AMICA pipelines. This script uses the ESS
    % metadata in combination with a batch config or manual inputs.
    % The script contains four main sections LOAD,MERGE,WARP and EVENTS.
    %
    %LOAD: loads the file based on the correct loading functions and removes
    % the NONEEG channels and fiducials.
    %MERGE: allow for the mergeing of multiple files,changing or sampling rate 
    % and the renaming of all events. Any Event name changes are saved in a key file.
    %WARP: warps the channel loctions of the experiment to the locations of    % the MNI head using the coregestier function.
    %EVENTS: uses the HED tags or other denoted events to create new events to
    % outline the data for vised marks. The marks created at this stage are to
    % designate InTask from OutTask for ICA purposes.
    %
%% From Batch               file_strswap 
%--------------------------------------------------------------------------
% File :                    [batch_dfn]
% Location:                 [batch_dfp]
%
%% From Config              key_strswap        Description
%-----------------------------------------------------------------------------------------------------------------------------
% metadata.tMatrix =        [tMatrix]          Matrix used to warp your location files to MNI head       
% metadata.Onevents =       [Onevents]         Events that represent HED tag 'Custom/Marks/RecStart'    
% metadata.Offevents =      [Offevents]        Events that represent HED tag 'Custom/Marks/RecStop'
% metadata.Inevents =       [Inevents]         Events that represent HED tag 'Custom/Marks/InEvent'
% metadata.loadType =       [loadType]         ESS or OTHER type of study you are loading
% metadata.plugin =         [modality]         System used for recording 
% metadata.lfn =            [locs_file_name]   Path to montage or naming convention for subject specific files
% metadata.oneloc =         [oneloc]           1 if you are using a single montage location file, 0 for subject specific files        
% metadata.NotEEG_chans =   [NotEEG_chans]     Channel numbers that do not contain EEG data
% metadata.change_srate =   [change_srate]     Resample the srate at lower Hz, 0 is no, anything else is the new rate
% metadata.merges =         [merges]           The number for files for each subject, 1 for no merges, '' if changes
% metadata.mergefiles =     [mergefiles]       The names of your merges files using swap strings, as a string list, '' for manual
% metadata.ref_loc_file =   [ref_loc_file]     Location of MNI head locs if not in default misc folder 
% metadata.filerename =     [filerename]       Name of the output file using a swap string, useful for long names
% metadata.erename =        [erename]          Name of the file containing all the events and there renames for each merge
%% LOAD - Load Type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% If the loadtype parameter is not filled out in the config this will ask
% pop a GUI to ask for it. Needed to know what else need to be asked for.

setpath4init;

% Options are ESS or OTHER
metadata.loadType = [loadType];

if isempty(metadata.loadType)
    % If no loadtype GUI to ask for it
    logging_log('INFO', 'No loadType was specified in the Config File');
    logging_log('INFO', 'Please Follow the GUI Instructions...');
        results=inputgui( ...
            {1 1 1 1}, ...
            {...
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string', 'Please Choose a Load Type:'}, ...
            {'Style','checkbox','string','Level 1 ESS Capsule - study_description.xml was loaded into Batch','value',0}, ... 
            {'Style','checkbox','string','Custom Folders - Raw files were loaded into batch','value',0}, ... 
            }, ...
            'pophelp(''s00_StudyBuddy.htb'');', 'Missing Necessary Config Parameters' ...
            );
    % Results
    if results{1} == 1
        metadata.loadType = 'ESS';
    elseif results{2} == 1
        metadata.loadType = 'OTHER';
    else
        error('WARNING: No loadType was specified')
    end
end


% Set up and clear EEG WORKSPACE
ALLCOM = [];
ALLEEG = [];
CURRENTSET = 0;
CURRENTSTUDY = [];
LASTCOM = [];
PLUGINLIST = [];
STUDY = [];
%% LOAD -  ESS capsule metadata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Collects the metadata from a level 1 capsule using the ESS built in
% function level2study (level to study)

if strcmp(metadata.loadType,'ESS')  
    logging_log('INFO', '******************LOADING ESS CAPSULE*******************');  
    logging_log('INFO', ['Subject File Name:' '[batch_dfn]']);
    
    % Loads the level 1 object
    try
        obj = level2Study('level1XmlFilePath', '[batch_dfp]');
    catch
        error('WARNING: Could not load the capsule! ESS plugin error.')
    end

    % Finding the Session Number fiolder by searching for matching file name
    for i = 1:length(obj.level1StudyObj.sessionTaskInfo)
        if strcmp(obj.level1StudyObj.sessionTaskInfo(i).dataRecording.filename,'[batch_dfn]')
        metadata.thisfile = (i);
        logging_log('INFO', ['ESS Study Subject Number: ' num2str(i)]);
        end
    end
    
   % Find the necessary variables from the object
    try
        % Modality
        metadata.plugin = obj.level1StudyObj.recordingParameterSet.modality(1).name;
        % sRate
        metadata.change_srate = str2double(obj.level1StudyObj.recordingParameterSet.modality(1).samplingRate);
        % Locs File Name
        % These are always individual files - specific to each subject
        metadata.lfn = obj.level1StudyObj.sessionTaskInfo((metadata.thisfile)).subject.channelLocations;
        % File Path to Session Folder
        metadata.fp = ['[batch_dfp]' 'session/' num2str(metadata.thisfile) '/'];    
        % oneloc - always 0 in ESS
        % Always individual files - specific to each subject
        metadata.oneloc = 0;  
    catch
        error('WARNING: ESS capsule does not contain the required information!')
    end
end
%% LOAD - OTHER metadata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Collects the metadata from config, if config is empty GUIs are used to
% aquire the informataion.

if strcmp(metadata.loadType,'OTHER') 
    logging_log('INFO', '******************LOADING RAW FILES*******************');
    logging_log('INFO', ['Subject File Name:' '[batch_dfn]']);
    
        % Save the file path
        metadata.fp = '[batch_dfp]';  
        
        % Modality
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        metadata.plugin = [modality];
        % If no modality use GUI to ask for it
        if isempty(metadata.plugin)
            logging_log('INFO', 'No Modality was specified in the Config File');
            logging_log('INFO', 'Please Follow the GUI Instructions...');
                results=inputgui( ...
                    {1 1 1 1 1 1 }, ...
                    {...
                    {'Style', 'text', 'string',blanks(100)}, ...
                    {'Style', 'text', 'string', 'Please Specify the experiment Modality'}, ...
                    {'Style','checkbox','string','BIOSEMI','value',0}, ... 
                    {'Style','checkbox','string','BRAINVISION','value',0}, ... 
                    {'Style','checkbox','string','EEG Set, or NETSTATION binary file','value',0}, ... 
                    {'Style','checkbox','string','OTHER','value',0}, ... 
                    }, ...
                    'pophelp(''s00_studyBuddy.htb'');', 'Missing Necessary Config Parameters' ...
                    );
                % Results
                if results{1} == 1
                    metadata.plugin = 'BIOSEMI';
                elseif results{2} == 1
                    metadata.plugin = 'BRAINVISION';
                elseif results{3} == 1
                    metadata.plugin = 'EEG';
                else
                    error('WARNING: No Modality was Specified')
                end
        end
        
        % oneloc
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        metadata.oneloc = str2num([oneloc]);
        % If no oneloc GUI to ask for it
        if isempty(metadata.oneloc) || (((metadata.oneloc) ~= 1) && ((metadata.oneloc) ~= 0))
            logging_log('INFO', 'No Location File Method specified in the Config File');
            logging_log('INFO', 'Please Follow GUI Instructions...');
                results=inputgui( ...
                    {1 1 1 1}, ...
                    {...
                    {'Style', 'text', 'string',blanks(100)}, ...
                    {'Style', 'text', 'string', 'Please Specify how your locations are saved:'}, ...
                    {'Style','checkbox','string','One Montage - or an averaged file to be shared','value',0}, ... %r2
                    {'Style','checkbox','string','Individual Location Files - for each subect in the raw folder with the eeg data','value',0}, ... %r2
                    }, ...
                    'pophelp(''s00_studyBuddy.htb'');', 'Missing Necessary Config Parameters' ...
                    );
                % Results
                if results{1} == 1
                    metadata.oneloc = 1;
                elseif results{2} == 1
                    metadata.oneloc = 0;
                else
                    error('WARNING: No Location File Method was Specified')
                end
        end
        
        % Locs File Name
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        try
            metadata.lfn = [locs_file_name];
        catch
            metadata.lfn = '';   
        end
        
        % If the plugin is EEG (Netstation), then the locations exist in the file already, and noe loc file is needed
        if isempty(metadata.lfn)
            if strcmp(metadata.plugin,'EEG')
                metadata.lfn = 'Default';
            end
        end
        
        % If no Location File name use GUI to ask for it
        if isempty(metadata.lfn)
            logging_log('INFO', 'No Location File Name specified in the Config File');
            logging_log('INFO', 'Please Follow GUI Instructions...');
                results=inputgui( ...
                    {1 1 1 1 1 1 1}, ...
                    {...
                    {'Style', 'text', 'string',blanks(100)}, ...
                    {'Style', 'text', 'string', 'Please Specify your Recording Loaction File Name:'}, ...
                    {'Style', 'text', 'string', '1. If you have only one location file for all the subjects specify the path.'}, ...
                    {'Style', 'text', 'string', '       Example (analysis/support/misc/BioSemi_BUCANL_7Eyes.sfp)'}, ...
                    {'Style', 'text', 'string', '2. If you have a unique location file for each subject use the string swap naming convention'}, ...
                    {'Style', 'text', 'string', '       Example [batch_dfn,.,-1]_locs.elc'}, ...
                    {'Style', 'edit', 'string', '', 'tag', 'edt_fl'}, ... 
                    }, ...
                    'pophelp(''s00_studyBuddy.htb'');', 'Missing Necessary Config Parameters' ...
                    );
                % Results
                try
                    metadata.lfn = (results{1});
                catch
                    error('WARNING: No Location File Name was Specified')
                end
        end 
end
%% LOAD - For Both
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The following metadata varibles need to be generated based off of the 
% information given despite ESS or OTHER.

% Data File Name and Path
metadata.dfnp = [ metadata.fp '[batch_dfn]'];
% Data File Extension
metadata.ext = metadata.dfnp(end-3:end);

% Srate change 0 or the same value is a no, any other number will be the new srate
metadata.change_srate = str2num([change_srate]);

% Config 1 means one common file, 0 means individual files for each subject
if metadata.oneloc == 0
    % MNI Locs File Name and path - based on unique file name - To Be Made
    metadata.lfn_mni = ([metadata.fp metadata.lfn(1:end-4) '_MNIlocs.elc' ]);
    % Locs File Name and Path
    metadata.lfnp = ([metadata.fp metadata.lfn]);
end
if metadata.oneloc == 1
    % MNI Locs File Name and Path - based on data file name - To Be Made
    metadata.lfn_mni = ([metadata.dfnp(1:end-4) '_MNIlocs.elc' ]);
    % Locs File Name and Path - now points to the one file
    metadata.lfnp = (metadata.lfn);  
end

% Marks Events File Name and Path - To Be Made
metadata.efnp_marks = ([metadata.dfnp(1:end-4) '_mark_events.tsv' ]);        
%% LOAD - Find the plugin needed
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Collects the modality system name and matches it with the corresponding
% plugin name.
if      (strcmp(metadata.plugin,'BIOSEMI'))
     metadata.plugin = 'Biosig';
elseif  (strcmp(metadata.plugin,'BRAINVISION'))
     metadata.plugin = 'bva-io';
elseif  (strcmp(metadata.plugin,'EEG'))
     metadata.plugin = 'EEG';
else
     error(['WARNING: The file modality extension or name' metadata.plugin ' and ' metadata.ext ' is not recorgnized!']);
end
%% LOAD - Install the plugin if needed
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Searches the eeglab plugins to see if any of the folders have the needed 
% plugin name in it. Version number doesnt matter. If it is not there e GUI
% will ask for a install.

% If it is EEG.set a plugin is not needed
if ~strcmp(metadata.plugin,'EEG')
    d = dir('analysis/support/dependencies/eeglab_asr_amica/plugins/');
    flag = 0;
    for i = 1:length(d);
        if  strfind(d(i).name,metadata.plugin);
            flag = 1;
        end 
        if (flag == 1) && (i == length(d))
            logging_log('INFO', ['Import plugin ' metadata.plugin ' Found']);
        end
        if (flag == 0) && (i == length(d))
            logging_log('INFO', ['Import plugin ' metadata.plugin ' NOT Found - Please confirm download in GUI Pop Up']);
            % Automatic Install of plug in if needed
            tic;
            plugin_askinstall(metadata.plugin);
            logging_log('INFO', ['Downloading Plugin took: ' num2str(toc) 'sec.']);
        end
    end
end
%% MERGE - Set Up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% If no merge number was listed in the Config, asks user for the number of 
% files they would like to merge. If they give a number >1 then they are
% asking for a merge

% Number of Merge files checking config
metadata.merges = str2num([merges]);
if isempty(metadata.merges) 
    % If no merge number in config use GUI to ask for it
    logging_log('INFO', 'No Merges were requests found in Config File');
    logging_log('INFO', 'Please Follow GUI Instructions...');
    results=inputgui( ...
        {1 1 1 1}, ...
        {...
        {'Style', 'text', 'string',blanks(100)}, ...
        {'Style', 'text', 'string', 'Would you like to merge other files to this one?'}, ...
        {'Style', 'text', 'string', 'Please type in the number of TOTAL files. Type 1 to use just this file.'}, ...
        {'Style', 'edit', 'string', '', 'tag', 'edt_fl'}, ... 
        }, ...
        'pophelp(''s00_studyBuddy.htb'');', 'Missing Necessary Config Parameters' ...
        );
    % Results
    try
        metadata.merges = str2num(results{1});
    catch
        error('WARNING: No merge number was specified or input was Not a Number')
    end   
end

% A number 1 or another number was used
if metadata.merges == 1
    logging_log('INFO', 'No Merging Requested')
elseif metadata.merges >1
    logging_log('INFO', ['Preparing to Merge ' num2str(metadata.merges) ' files together']);
else
    error(['WARNING: The number ' num2str(metadata.merges) ' is not a supported merge number']);
end
%% MERGE - File Names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% If merges are needed gathers the file names of the other files
% Collected as 'file1','file2','file3'... and made into cell array

if metadata.merges ~= 1
    % Config - {[merge_files]} decode the string swaps that are used, there
    % needs to be a string swap for each of the merged files.
    metadata.mergefiles = {[mergefiles]};
    try
        for g = 1:length(metadata.mergefiles)
            metadata.mergefiles{g} = key_strswap(metadata.mergefiles{g},'batch_dfn','IC_trn_P01_F_1.bdf');
        end
    catch
        warning('WARNING: You did not uses string swaps for your merges you file names wont work for more than one file');
    end
    % Manual - Use a GUI pop Up to browse for the other files
    % This will be common as many studies will have just the odd files that
    % needs to be merged. Or the files they are mergeing do not have a
    % common naming pattern.
        if isempty((metadata.mergefiles{1}))
            logging_log('INFO', 'Please Follow GUI Instructions...');
            [metadata.mergefiles, inputpath] = uigetfile2(['*' metadata.ext '*'],[ 'Select the ' num2str(metadata.merges - 1) ' files you would like to merge into the loaded file'], 'multiselect', 'on');
        end

    % Check to see if they loaded the right number of files
    if (metadata.merges - 1) ~= length(metadata.mergefiles)
        warning('CATION: You didnt load as many files as you indicated you would')
        error(['WARNING: You need ' num2str(metadata.merges) 'files total. Please browse for only the additional ' num2str(metadata.merges - 1)]);
    end
end
%% LOAD -  Load ALLEEG Data Files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The Main loading loop, that trys different loading functions based on
% what plugin was downloaded. The loop loads each of the merged files,
% then saves each of them into ALLEEG, and populates the filename field
% which is used later for EEG functions.
% This section also converts all of the events for each file into strings,
% and finds all of the unique events in the file which will be used for
% renameing.
% Finally this section records the lengths of each of the files as they
% load to determine where each file starts and stops.

% ToDo:
% exp_eval ? might be a option here as a generic loader
% Browse Merge loading needs to be loaded in raw for loadtype to be used
logging_log('INFO', 'Starting the Main Loading Loop');
tic;
metadata.bounds = 0;
for k = 1:(metadata.merges)
    % First file is loaded normally
    if k == 1
       metadata.loadthis = metadata.dfnp;
       metadata.alle = 0;
    else
       % Other files after the first are the merge files names
       metadata.loadthis = [ metadata.fp metadata.mergefiles{k-1}];
    end

    % Start the main loading test loop
    try
        try
            % Modality 1
            if      strcmp(metadata.plugin,'Biosig')
                try
                    logging_log('INFO', 'Trying to read BDF using pop_biosig');
                    EEG = pop_biosig(metadata.loadthis);
                catch
                    logging_log('INFO', 'Trying to read BDF using pop_readbdf');
                    EEG = pop_readbdf(metadata.loadthis);
                end

            end
            % Modality 2
            if      strcmp(metadata.plugin,'bva-io');
                    EEG = pop_loadbva(metadata.loadthis);
            end 
            if      strcmp(metadata.plugin,'EEG') || strcmp(metadata.plugin,'NETSTATION')
                try
                    % Can not merge set files but if the files are complete then they can be loaded at least
                    % Contains swap string 
                    logging_log('INFO', 'Trying to read SET using pop_loadset');
                    EEG = pop_loadset('filename','[batch_dfn]','filepath',metadata.fp);
                    warning('CAUTION: Can not load merge files using this function');
                catch
                    logging_log('INFO', 'Trying to read raw using pop_readegi');
                    EEG = pop_readegi(metadata.loadthis,[],[],'auto'); 
                    % Load remove the reference channel - this brings it back
                    warning('NOTE: Returning Empty Reference Channel and its 0 data');
                    EEG.data(end + 1,:) = zeros(1,length(EEG.data));
                    EEG.nbchan = size(EEG.data,1);
                    for h = 1:length(EEG.chaninfo.nodatchans) 
                        if (EEG.chaninfo.nodatchans(h).type) == 'REF'
                            EEG.chanlocs(end + 1) = EEG.chaninfo.nodatchans(h);
                            EEG.chaninfo.nodatchans(h) = [];
                        end
                    end
                    EEG = eeg_checkset(EEG);  
                end

            end 
        catch
                    % Last Resort for loading
                    warning('CAUTION: Trying to read BDF using exp_eval as a LAST RESORT!');
                    EEG = exp_eval(metadata.loadthis);  
        end
    catch
        % Result if nothing worked
        error('WARNING: Your files could not be loaded!');
    end
    
    % Save the EEG into ALLEEG  - needed for merge
    [ALLEEG EEG CURRENTSET] = pop_newset( ALLEEG, EEG, CURRENTSET,'setname','MergedEEG');
    
    % Save ALLEEG filenames field - needed for merge
    ALLEEG(k).filename = metadata.loadthis;
    
    % Find length of each files data, to know the bounds between files
    % This in fo is used when renameing events in each files domain
    try
        metadata.bounds(k) = metadata.bounds(k-1) + length(ALLEEG(k).data);
    catch
        metadata.bounds(k) = length(ALLEEG(k).data);
    end
    
    % Convert all event types to strings - needed for event renameing
    for p = 1:length(ALLEEG(k).event)
        if isnumeric(ALLEEG(k).event(p).type)
            ALLEEG(k).event(p).type = num2str(ALLEEG(k).event(p).type);
        end
    end
    
    % Find file with most unique events - needed for event renameing
    % The size of the erename array is based of this.
    try
        metadata.nume(k) = length(unique({ALLEEG(k).event.type}));  %???????????????? {} or [] might change depend on # of merges
    catch
        metadata.nume(k) = length(unique([ALLEEG(k).event.type]));     
    end
    metadata.alle = max(metadata.alle,metadata.nume(k));
   
%End of the loading loop
end

logging_log('INFO', ['Loading Merges took: ' num2str(toc) 'sec.']);
%% MERGE - Merge ALLEEG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Merges all file in ALLEEG - be warned if testing! Clear EEGLAB first!

tic;
% If the number of merges is not 1 then a merge is requested
if metadata.merges ~= 1  
    % Correct the number of channels if nesscary
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    metadata.mergechan = unique([ALLEEG.nbchan]);
    if length(metadata.mergechan) > 1
        logging_log('INFO', ['Found a discrepancy in the number of channels between the merge files']);
        logging_log('INFO', 'Please Follow GUI Instructions...');
        % Notify the user that there is a problem
        results=inputgui( ...
            {1 1 1 1 1}, ...
            {...
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string','Found a discrepancy in the number of channels between the merge files'}, ... 
            {'Style', 'text', 'string',['Merge files have the corresponding number of channels: ' num2str([ALLEEG.nbchan]) ]}, ...
            {'Style', 'text', 'string',['Your channels need to be reduced to to match the lowest amount of: '  num2str(min([ALLEEG.nbchan]))]}, ... 
            {'Style', 'text', 'string','     Note: this is common for the Biosemi based on your settings.'}, ...
            }, ...
            'pophelp(''s00_studyBuddy.htb'');', 'You channels will be reduced!' ...
            );
        % Remove the excess channels
        % There is still another opportunity to remove channels, this is
        % simply to allow for merging.
        for j = 1:length(ALLEEG) 
            if ALLEEG(j).nbchan ~= (min(metadata.mergechan))
                logging_log('INFO', ['Removing channels from file: '  num2str(j)]);
                ALLEEG(j).data((min(metadata.mergechan)+ 1):end,:) = [];
                ALLEEG(j).nbchan = min(metadata.mergechan);
                ALLEEG(j).chanlocs((min(metadata.mergechan) + 1):end) = [];
            else
                logging_log('INFO', ['File: '  num2str(j) ' did not need channel removals']);
            end
        end
    else
        logging_log('INFO', 'All Merges have the same number of channels');
    end
    
    % Correct the srate if nesscary
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    metadata.mergesrate = unique([ALLEEG.srate]);
    if length(metadata.mergesrate) > 1
        logging_log('INFO', ['Found a discrepancy in the sampling rate between the merge files']);
        logging_log('INFO', 'Please Follow GUI Instructions...');
        % Notify the user that there is a problem
        results=inputgui( ...
            {1 1 1 1 1}, ...
            {...
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string','Found a discrepancy in the sampling rate between the merge files'}, ... 
            {'Style', 'text', 'string',['Merge files have the corresponding sampling rates: ' num2str([ALLEEG.srate]) ]}, ...
            {'Style', 'text', 'string',['Your sampling rates need to be reduced to to match the lowest frequency: '  num2str(min([ALLEEG.srate]))]}, ... 
            {'Style', 'text', 'string','     Note: this is common for the Biosemi based on your settings.'}, ...
            }, ...
            'pophelp(''s00_studyBuddy.htb'');', 'You sampling rate will be reduced!' ...
            );
        tic
        % Resample
        % There is another opertunity to rsample later if the data is still
        % not to you liking, this is just to allow the merge to happen
        for j = 1:length(ALLEEG) 
            if ALLEEG(j).srate ~= (min(metadata.mergesrate))
               logging_log('INFO', ['Resampling file: '  num2str(j)]);
               ALLEEG(j) = pop_resample(ALLEEG(j),(min(metadata.mergesrate)));
            else
                logging_log('INFO', ['File: '  num2str(j) ' did not need to be resampled']);
            end
        end
        logging_log('INFO', ['Resampling to new sRate took: ' num2str(toc) 'sec.']);
    else
        logging_log('INFO', 'All Merges have the same srate');
    end
    % Actual Merge
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Always preformed using the stored ALLEEG
    EEG = pop_mergeset(ALLEEG,1:metadata.merges);
else
    % No merge
    EEG = ALLEEG(1);
    CURRENTSET = 1;
end
logging_log('INFO', ['Merging ALLEEG together took: ' num2str(toc) 'sec.'])

% Adds a 0 to the start to complete the bounds on the first file
% EEG.data = | File 1 | File 2 | File 3 | File 4 | File 5 |....
% bounds    (1)      (2)      (3)      (4)      (5)      (6)
metadata.bounds = [ 0 metadata.bounds];
%% EVENTS - Existing File
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Checks for WEvent renaming file and sets up a case 0,1. If a file is found it skips down
% to the load function below.

metadata.efile = 0;
if exist(metadata.efnp_marks,'file')
    metadata.efile = 1;
    logging_log('INFO', 'Task Marks File Exists');
else
    metadata.efile = 0;
    logging_log('INFO', 'Task Marks File Does Not Exist');
end 
%% MERGE - Events Rename Cell Array
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This section creates a cell array containing the all the unique events
% for each files and their old names. The cell array is padded with 'placeholder's
% The config is already in the form of the final step, manual version goes
% through a few more versions first starting from alle.

% It will look like this in the end:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Config Example for reference, uses the cell 'plholdr' for empties must same size
% metadata.erename = file1    { 'Type#' 'TypeReName' 'Type#' 'TypeReName' 'Type#' 'TypeReName' ;
%                    file2      'Type#' 'TypeReName' 'Type#' 'TypeReName' 'Type#' 'TypeReName' ;
%                    file3      'Type#' 'TypeReName' 'Type#' 'TypeReName' 'Type#' 'TypeReName' ;
%                    file4      'Type#' 'TypeReName' 'Type#' 'TypeReName' 'placeholder' 'placeholder' ;}
   
% ESS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESS will automatically rename the events to the study description 'label' 
    
    if strcmp(metadata.loadType,'ESS') && (metadata.efile == 0)
        % Get event renames from the ESS metadata
        metadata.erename = cell(1,length(obj.level1StudyObj.eventCodesInfo)*2);
        for i = 1:length(obj.level1StudyObj.eventCodesInfo)
            metadata.erename{1,i*2 -1} = (obj.level1StudyObj.eventCodesInfo(i).code);
            metadata.erename{1,i*2} = obj.level1StudyObj.eventCodesInfo(i).condition.label;
        end
    end 

% Other
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Other files use a file name to look up the contents file will look like:
% Filenumber %s OldName %s NewName
% The file can have extra names but can not be missing event names
    if strcmp(metadata.loadType,'OTHER') && (metadata.efile == 0) 
        metadata.erename = [erename];   
        try
            ere_file = fopen(metadata.erename);
            metadata.erename_file = textscan(ere_file,'%s %s %s');
            fclose(ere_file);
            metadata.erename = cell((metadata.merges),(length(metadata.erename_file{1}))*2);
            for k=1:length(metadata.erename_file{1})
                metadata.erename{str2num(metadata.erename_file{1,1}{k}),k*2 -1} = metadata.erename_file{1,2}{k};
                metadata.erename{str2num(metadata.erename_file{1,1}{k}),k*2} = metadata.erename_file{1,3}{k};
            end
            catch
                warning('No Event Renaming File Found. Manual Renaming will be needed.')
        end
        disp ('NAME:');
        disp (metadata.erename);
        metadata.erename(find(cellfun(@isempty,metadata.erename))) = {'placeholder'};
    end
     
% erename cell matrix is complete
%% MERGE - Events Rename Manual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This section cretes the erename cell array from GUI responses. Starting
% will alle, then building the config looking skeleton and asking the user
% to fill in any new renaming columns. Rows are done by file and each one
% is a new GUI pop up.

% No Config start up a manual GUI
if isempty(metadata.erename) && (metadata.efile == 0)
    % Outline the rename shape is 2x the length of unique events in alle
    metadata.erename = cell([(metadata.merges),metadata.alle*2]);
    % Fill the array creted  with each merge file's unique event types
    for u = 1:metadata.merges
        metadata.erename(u,1:2:length(unique({ALLEEG(u).event.type}))*2) = (unique({ALLEEG(u).event.type}));
    end
    % Fill any empty cells with a placeholder event that doesnt do anything
    metadata.erename(find(cellfun(@isempty,metadata.erename))) = {'placeholder'};
    logging_log('INFO', 'Rename events for each of the merged files');
    logging_log('INFO', 'Please Follow GUI Instructions...');
    for i = 1:metadata.merges  
        metadata.erenamegui = [];
        % Make GUI display string containing 2 of each oldname
        % Only goes to the length of the unique events nume so placeholders and not displayed
        for u = 1:(metadata.nume(i))
            metadata.erenamegui = [metadata.erenamegui (metadata.erename(i,u*2 - 1)) ',' (metadata.erename(i,u*2 -1)) ','];
        end
        % Remove last comma
        metadata.erenamegui = metadata.erenamegui(1:end-1);
        logging_log('INFO', ['Renaming events for file: ' num2str(i)]);
        % Manual GUI
        results=inputgui( ...
            {1 1 1 1 1 1 1 1}, ...
            {...
            {'Style', 'text', 'string',blanks(300)}, ...
            {'Style', 'text', 'string',[ 'Rename your events for file: ' num2str(i) ' of ' num2str(metadata.merges) ' merges.']}, ... 
            {'Style', 'text', 'string','In the string below each event is listed twice. Leave the first instance it is the old event type. The second number is what you would like to rename this event to. '}, ...
            {'Style', 'text', 'string','     For Example:  1,1,2,new2name,3,33  - leaves event 1 called event 1,renames event 2 to new2name, and renames 3 to 33'}, ... 
            {'Style', 'text', 'string', strcat(cell2mat(metadata.erenamegui))}, ...
            {'Style', 'edit', 'string', strcat(cell2mat(metadata.erenamegui)), 'tag', 'edt_fl'}, ...
            {'Style', 'text', 'string',' Remember that event names thoughout merges have to remain consistant.'}, ... 
            {'Style', 'text', 'string',' Do NOT use RecStart, RecStop, InEvent or placeholder as event names unless you understand the Marks System that these events use!'}, ... 
            }, ...
            'pophelp(''s00_studyBuddy.htb'');', 'Rename your events for each file' ...
            );
        
        % Results 
        % String is split into cells/cols and saved into the row for the merge file number
        metadata.erename(i,1:length(strsplit(results{1},','))) = strsplit(results{1},',');  
    end
end
%% MERGE - Events Renaming Main Loop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Transfers all of the events names over to what you wanted them to be 
% called using the erename cell array.
% Depending on the way erename was created it might be very large
tic;
if metadata.efile == 0
    % Go through all events
    for j = 1:length(EEG.event)
        % Go through all time ranges/files/rows
        for i = (1:length(metadata.bounds)-1)
            % If in the time range
            if metadata.bounds(i+1) >= EEG.event(j).latency && EEG.event(j).latency  >= metadata.bounds(i)
                % Finds matching old event type and the rename find index + 1 new event name
                try
                    if ~strcmp(EEG.event(j).type,'boundary')
                        metadata.eventtypetmp = EEG.event(j).type;
                        EEG.event(j).type = metadata.erename{i,(find(ismember(metadata.erename(i,:),(EEG.event(j).type)),1)) + 1};
                    else
                        % If it is not a unique event then it is a boundary
                        logging_log('INFO', ['Found' (EEG.event(j).type) ' at event number ' num2str(j)]);
                    end
                 catch
                    EEG.event(j).type = [];
                 end
                % Event that was not listed in the config!    
                if   isempty(EEG.event(j).type);
                    EEG.event(j).type = [metadata.eventtypetmp '_NoRenameConfig' ];
                    logging_log('INFO', ['WARNING: Found unspecified event at event number ' num2str(j) ' renamed to ' EEG.event(j).type]);
                end
            end
        end
        % If duration exists
        try
            % If duration is empty make it 0
            if isempty(EEG.event(j).duration)
                EEG.event(j).duration = 0;
            end
        % If duration doesnt exist create it    
        catch
            EEG.event(j).duration = 0;
        end     
    end
end
logging_log('INFO', ['Renaming Events took: ' num2str(toc) 'sec.']);
%% LOAD - Resample Srate
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This section will change the srate is the user gives the config as a
% number to resample to, if it is a 0 then it remains the same, and if the
% config is empty then a manual GUI will pop up. Form the GUI if they enter
% the same srate then nothing happens, if they enter a different one then it
% is resampled to that.

tic;
% NO(0) - do not change sampling rate
if metadata.change_srate == 0
   metadata.change_srate = EEG.srate;
 
% MANUAL('') - No config
elseif isempty(metadata.change_srate) 
        % If no sRate GUI to ask for it
        logging_log('INFO', 'No sRate in config');
        logging_log('INFO', 'Please Follow GUI Instructions...');
        results=inputgui( ...
            {1 1 1 1 1}, ...
            {...
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string', ['Your current file srate is: ' num2str(EEG.srate)]}, ...
            {'Style', 'text', 'string', 'Please specify the Recording sRate per second that you wish to resample to:'}, ...
            {'Style', 'edit', 'string', '', 'tag', 'edt_fl'}, ... 
            {'Style', 'text', 'string', 'To load the file as is please type the same number or a 0'}, ...
            }, ...
            'pophelp(''s00_studyBuddy.htb'');', 'Missing Necessary Config Parameters' ...
            );
        % Results
        try
            metadata.change_srate = str2num(results{1});
        catch
            error('WARNING: No sRate was specified or input was not a number')
        end
    
        % If the number is different then resample, otherwise take EEG default from EEGLAB
        if (metadata.change_srate ~= EEG.srate) && (metadata.change_srate ~= 0)
           EEG = pop_resample(EEG,metadata.change_srate);
           logging_log('INFO', ['Resampling to new sRate took: ' num2str(toc) 'sec.']);
        else
           metadata.change_srate = EEG.srate;
        end
        
% YES(#) - config has the number, same srate as existing wont change anything
else 
   EEG = pop_resample(EEG,metadata.change_srate);
   logging_log('INFO', ['Resampling to new sRate took: ' num2str(toc) 'sec.'])
end

% Make sure the new srate is slower then the old one
if  metadata.change_srate > EEG.srate
    error('WARNING: Can not resample to a faster frequency');
end
%% LOAD - Load Original Location File ESS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Loads the original location file, whether it is a single file or a
% subject specific file.
tic;
% Removes the non EEG channels from the locations and from the data

if strcmp(metadata.loadType,'ESS') && ~strcmp(metadata.lfn,'Default')
    metadata.remDataInd = []; % Indexes
    metadata.remChans = []; % Names
    metadata.keepData = []; % Names
    metadata.remChansInd = []; % Indexes
    
    % Read in locations
    EEG.chanlocs = readlocs(metadata.lfnp);
    
    % .Chanlocs
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    % Find EXG Channel Names
    for mod = 1: length(obj.level1StudyObj.recordingParameterSet.modality)
        if strcmp(obj.level1StudyObj.recordingParameterSet.modality(1,mod).type,'EEG')
            metadata.remChans = strsplit(obj.level1StudyObj.recordingParameterSet.modality(1,mod).nonScalpChannelLabel,',');
        end
    end

    % Find EXG Noise Data Channel Indexes
    for j = 1:length(metadata.remChans)
        metadata.remChansInd = [metadata.remChansInd find(strcmp(metadata.remChans(j),{EEG.chanlocs.labels}))];
    end
    
    % Find Fiducial No Data Channel Indexes and Names
    for p = 1:length(EEG.chanlocs)   
        if strcmp(EEG.chanlocs(p).type,'FID')
            metadata.remChansInd = [metadata.remChansInd p];
        end
    end
    
    % Add Channel Indexes to .nodatchans
        % Fiducials
        % EXG
    EEG.chaninfo.nodatchans = EEG.chanlocs(metadata.remChansInd);
    % Remove Channel Indexes from .chanlocs
    EEG.chanlocs(metadata.remChansInd) = [];
    EEG.nbchans = length(EEG.chanlocs);
    
    
    % .Data
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    % Find Noise Data Indexes
    for mod = 1: length(obj.level1StudyObj.recordingParameterSet.modality)
        if strcmp(obj.level1StudyObj.recordingParameterSet.modality(1,mod).type,'Noise')
            metadata.remDataInd = str2num(obj.level1StudyObj.recordingParameterSet.modality(1,mod).startChannel) : ...
                                    str2num(obj.level1StudyObj.recordingParameterSet.modality(1,mod).endChannel);
            
        end
    end
    
    % Find EXG Noise Data Indexes using names in the all labels feild
    for mod = 1: length(obj.level1StudyObj.recordingParameterSet.modality)
        if strcmp(obj.level1StudyObj.recordingParameterSet.modality(1,mod).type,'EEG')
            metadata.remChans = strsplit(obj.level1StudyObj.recordingParameterSet.modality(1,mod).nonScalpChannelLabel,','); 
            metadata.keepData = strsplit(obj.level1StudyObj.recordingParameterSet.modality(1,mod).channelLabel,',');
        end
    end
    
    % Find indexes
    for j = 1:length(metadata.remChans)
        metadata.remDataInd = [metadata.remDataInd find(strcmp(metadata.remChans(j),metadata.keepData))];
    end
    
    % Remove Noise Indexes from .data
        % In case there is excess in the bounds
        %      -Was the case for test RSVP study 257-290, with only 289 data
    while 1
        try
            EEG.data(metadata.remDataInd,:) = [];
                break;
        catch
            % Clear any removals that are not actually in the data
            metadata.remDataInd(find((metadata.remDataInd) > size(EEG.data,1))) = [];
        end
    end
    
end
    %% LOAD - Load Original Location File OTHER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Loads the original location file, whether it is a single file or a
% subject specific file. If the user loaded a file that does not match the
% size of the data a warning is displayed. Data will be removed to match
% the sizes if possible.

if strcmp(metadata.loadType,'OTHER') && ~strcmp(metadata.lfn,'Default')
    % Empty is a valid option - just disply warning
    try
        metadata.remChans = [remChans];
    catch
        warning('CAUTION: No channel removals specified in config, all channels will be considered EEG data!')
        metadata.remChans = [];
    end
    try
        metadata.remData = [remData];
    catch
        warning('CAUTION: No data removals specified in config, all channels will be considered EEG data!')
        metadata.remData = [];
    end
    
    logging_log('INFO', ['Removing remData and Loading Location files.']);
    
    % Remove EEG data rows
    %%%%%%%%%%%%%%%%%%%%%%%
    % Removes rows in the data that do not contain information
    if ~isempty(metadata.remData)
        EEG = pop_select(EEG,'nochannel',metadata.remData);    
    end
 
    %logging_log('INFO', ['Checking location files initial consistency']);
    %% Not Used ATM
% %     % Do a test load to see if the size of the locs file is correct
% %     [~,metadata.locloadnoteeg,metadata.locload,~] = pop_chanedit(EEG, 'load',{metadata.lfnp 'filetype' 'autodetect'});
% %     % Find anyt differences between the location file loaded and what is in
% %     % the data. If the diff is zero the load will work.
% %     metadata.locloadnoteeg = length(metadata.locloadnoteeg.nodatchans);
% %     metadata.locload = length(metadata.locload);
% %     metadata.chanlocdiff = EEG.nbchan - (metadata.locload - metadata.locloadnoteeg);
% %     logging_log('INFO', ['Current Channels: ' (num2str(EEG.nbchan))]);
% %     logging_log('INFO', ['Loaded Channels: ' (num2str(metadata.locload))]);
% %     logging_log('INFO', ['Specified Non EEG Channels: ' (num2str(length(metadata.NotEEG_chans)))]);
% %     logging_log('INFO', ['Autodetected Non EEG Channels: ' (num2str(metadata.locloadnoteeg))]);
% %     logging_log('INFO', ['Discrepancy: ' (num2str(metadata.locload)) ' - ' (num2str(metadata.locloadnoteeg)) ' = ' ...
% %         num2str(metadata.locload - metadata.locloadnoteeg) ' vs. ' (num2str(EEG.nbchan))]);
% %   
% % % Attempt at auto adjuster to match location files
% % % ATM just displays errors when location files dont match with the data
% %     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % %     % If the location file does not match the data 
% % %     try
% % %         % Data larger than channels - data removed to match
% %          if (metadata.chanlocdiff ~= 0)
% %          error(['WARNING: You location file is off by  ' num2str(abs(metadata.chanlocdiff)) ' channels compared to your data!']);
% % %             EEG.nbchan = metadata.locload - metadata.locloadnoteeg;
% % %             EEG.data = EEG.data(1:EEG.nbchan,:);
% % %             warning(['CAUTION: Had to cut off ' num2str(metadata.chanlocdiff) ' channels from the end, make sure this is right!']);
% % %             warning(['WARNING: Adjust your location file, it has more less channels than you have data!']);
% % %         else
% % %             % Good fit
% % %             logging_log('INFO', ['Location file is consistant with EEG.data']); 
% %          end
% % %     catch
% % %         % Data smaller than channels, cant add data
% % %         warning(['WARNING: Adjust your location file, it has more locations than you have data!']);
% % %         error(['WARNING: Cant read your non-EEG channels, cant add ' num2str(abs(metadata.chanlocdiff)) ' data channels']);
% % %     end
% %     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
% %     
    
    %% Remove Channels/Fids on Entry store in nodatchans
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    try
        % Use Designated Fids/NonEEG to correct the location file
        str = 'EEG=pop_chanedit(EEG, ''load'',{metadata.lfnp ''filetype'' ''autodetect''},';
        for t = 1:length(metadata.remChans)
                str = [ str '''changefield'',{' num2str(metadata.remChans(t)) ' ''datachan'' 0},'];
        end
        % Close and evaluate the statement
        str(end) = ')';
        str(end+1) = ';';
        eval(str);
    catch
        error('WARNING: Could not find or read location file!') ;
    end
end

logging_log('INFO', ['Loading Original Location File took: ' num2str(toc) 'sec.']);
%% LOAD - Events - NOT USED ATM, CAN PROBABLY BE TAKEN OUT
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% % Load Events
% importevent(metadata.mark_events_path,[],metadata.srate,'feilds',{'latency','type'});
% 
% 
% % %% Use the built in FileLoader/LocationLoader - loadAndPrepareRawFile
% % 
% % %Loads a .set file and deals with the location file loading properly
% % [EEG, dataRecordingParameterSet, allEEGChannels, allScalpChannels] = loadAndPrepareRawFile(...
% %                         obj.level1StudyObj, ...
% %                         metadata.file_path, ... %fileFinalPath %metadata.tmp_save_path or %
% %                         '/home/jad/EAndrew_Lofts/ESS_Pipeline/eeg_pipe_asr_amica/analysis/data/0_raw/Main_Study_Folder/level_1/' ,... %rootFolder
% %                         obj.level1StudyObj.sessionTaskInfo(metadata.thisfile).taskLabel,... %currentTask
% %                         obj.level1StudyObj.sessionTaskInfo(metadata.thisfile).subject(1).channelLocations,... %channelLocationFullPath
% %                         obj.level1StudyObj.sessionTaskInfo(metadata.thisfile).dataRecording(1).recordingParameterSetLabel, ...
% %                         obj.level1StudyObj.sessionTaskInfo(metadata.thisfile).sessionNumber,...% Session recording number only 1
% %                         1);% Data recording number only 1
% %                         %inputOptions.forTest); % Not included nargin
% % %Collect fiducials
% % EEG.chanlocs = readlocs(metadata.MNIlocs_path,'filetype','xyz');
%% WARP - Existing File
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Looks for configs or MNI file. If they are found they will be used. Sets
% up case 0,1 based on what will be used. Also finds the reference
% location.

% Determine which procedures need to be done
metadata.matrix = 0;
metadata.lfile = 0;

% Check for File
if exist(metadata.lfn_mni,'file')
    metadata.lfile = 1;
    logging_log('INFO', 'MNI location File Exists');
    logging_log('INFO', 'Using the provided MNI location file that already exists');
else
    logging_log('INFO', 'MNI location File Does Not Exist');
end   
%% WARP - TMatrix Config
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Looks for configs or MNI config. If they are found they will be used. Sets
% up case 0,1 based on what will be used. Also finds the reference
% location.

% Check for Config
try
    metadata.tMatrix = [tMatrix]; 
catch
    metadata.tMatrix = [];  
end

if ~isempty(metadata.tMatrix)
    metadata.matrix = 1;
    logging_log('INFO', 'Found a tMatrix loaded into batch config');
else
    logging_log('INFO', 'Config had no tMatrix');
end

% Check for Reference file location
try
    metadata.ref_loc_file = [ref_loc_file];
catch
    metadata.ref_loc_file = ''; 
end

if isempty(metadata.ref_loc_file)
    metadata.ref_loc_file = 'analysis/support/misc/standard_1020.elc';
    warning('CAUTION: No location reference file to warp to in config will use MNI surface given analysis/support/misc/standard_1020.elc');
end

if ((metadata.matrix == 1) && (metadata.lfile == 0)) 
    logging_log('INFO', 'Using transformation metadata.matrix to warp the ESS location files in MNI location files');
    EEG=warp_locs(EEG,metadata.ref_loc_file, ...
			 'landmarks',{'Nz','LPA','RPA'}, ...
  			 'transform',metadata.tMatrix, ...
  			 'manual','off');
end
%% WARP - Manual Tmatrix or GUI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% If there is no config matrix and no file then manual is needed

if (metadata.matrix == 0) && (metadata.lfile == 0)
    logging_log('INFO', 'No transformation matrix and MNI file can be found: these have to be created manually');
    logging_log('INFO', 'Please Follow GUI Instructions...');
        results=inputgui( ...
            {1 1 1 1 1 1  1 [3 1]}, ...
            {...
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string', 'Choose a method to warp your co-ordinate files to the MNI montage:'}, ...
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string', 'Method 1: Input a generic or specific transformation metadata.matrix'}, ...
            {'Style', 'text', 'string', '      Example: [-.5,-20,-6,-0.05,0.013,-1.58,10.2,11,12]'}, ...
            {'Style', 'edit', 'string', '', 'tag', 'edt_fl'}, ... 
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string', 'Method 2: Manually manipulate each montage'}, ...
            {'Style','checkbox','string','Manual Mode On','value',0}, ... 
            }, ...
            'pophelp(''StudyBuddy'');', 'Decide on how you want to warp the location montage' ...
            );
    
    % Same as a config uses the Tmtrix input
    if ~isempty(results{1})
       EEG=warp_locs(EEG,metadata.ref_loc_file, ...
                 'landmarks',{'Nz','LPA','RPA'}, ... % ToDo: Warping to a different fiducuials
                 'transform',str2num(results{1}), ...
                 'manual','off');  
    end
   
    % Manual generates the input
    if results{2} == 1
       logging_log('INFO', 'Please Follow GUI Instructions...');
       EEG=warp_locs(EEG,metadata.ref_loc_file, ... % ToDo: Warping to a different fiducuials
                 'landmarks',{'Nz','LPA','RPA'}, ...
                 'manual','on');   
    end
end
%% WARP - Save or Load MNI file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Saves the files just made if nothing exists. If there was a file above
% then script skipps to here.

% Save 
if metadata.lfile == 0
    logging_log('INFO', 'Saving MNI location file');
    writelocs(EEG.chanlocs,metadata.lfn_mni,'filetype','xyz');
end

% Load
% Skipped to here is the file exists
if metadata.lfile ==1
    logging_log('INFO', 'Loading MNI location file');
    tic;
    try
        EEG.chanlocs = readlocs(metadata.lfn_mni,'filetype','xyz');
    catch
        EEG.chanlocs = readlocs(metadata.lfn_mni); 
    end
    logging_log('INFO', ['Loading Warped Location File took: ' num2str(toc) 'sec.'])
end
%% LOAD - Purge Non EEG channels CAN PROBABLY BE TAKEN OUT DONT THINK EVER CALLED NOW
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Removes the nonEEG data channels. Depending on the loadtype sometimes the
% % data is larger and sometimes the locations is bigger. Either way the
% % large of the two is cut down in size to match.
% 
% logging_log('INFO', 'Removing Fiducials and other non Data channels from EEG.data');
% % Remove indecies of channels containing no EEG data
% % If it is a structure that means eeglab found them
% if ~isstruct(EEG.chaninfo.nodatchans)
%     EEG.chaninfo.nodatchans = metadata.NotEEG_chans;
% 
% %if (size(EEG.data,1) > length(EEG.chanlocs)) && ((EEG.nbchan) > length(EEG.chanlocs))
%     % Extra Data compared to loc channels loaded usually from ESS structures
%     logging_log('INFO', 'EEG data contains more data than channels...');
%     logging_log('INFO', 'Removing excess NON-EEG Data (unplugged, EXG, etc.) ');
%     if ~isempty(EEG.chaninfo.nodatchans)
%         EEG = pop_select(EEG,'nochannel',EEG.chaninfo.nodatchans);
%     end
% end
% %    EEG.nbchan = length(EEG.chanlocs);
% %else
% %    % Extra loc channels compared to data size loaded usually from OTHER raw files
% %    logging_log('INFO', 'More Channels then there is EEG Data...');
% %    logging_log('INFO', 'Removing Extra channels that support no EEG data (fiducials, unused, etc.)');
% %    EEG.chanlocs(EEG.chaninfo.nodatchans) = [];
% %    EEG.nbchan = length(EEG.chanlocs);
% %end
% 
% % String trim the channel labels to remove any empties
% for i=1:EEG.nbchan
%     EEG.chanlocs(i).labels=strtrim(EEG.chanlocs(i).labels);
% end

%% EVENTS - Set Up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Two methods of Task designtaion
% These cell arrays fill up with events that will be used to make marks

% Place events to denote recording On versus Recording Off.
% Marks will fill the areas outside of these event boundaries
metadata.RecOnEventRecOffEvent = 0;                         
metadata.RecOnevents = {};
metadata.RecOffevents = {};

% Place events to denote the events that are In Task time
% Marks will fill out the areas that are not close to any of these events
metadata.InTaskOutTask = 0;                                 
metadata.Inevents = {};

% Determine which procedures need to be done
metadata.matrix = 0;
metadata.ManualMarks = 0;

% Tallies to make sure intervals are complete
metadata.tallya = 0;
metadata.tallyb = 0;
metadata.tallyc = 0;
%% EVENTS - Existing On/Off or In ESS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% For ESS type only this section searches the HED tags for inbuilt marks.
%Sets the marks type to whatever it finds.

% ToDo: Test this with an actual ESS
if strcmp(metadata.loadType,'ESS') && (metadata.efile == 0)
    for p = 1:length(obj.level1StudyObj.eventCodesInfo)
        if any(strfind(obj.level1StudyObj.eventCodesInfo(p).condition.tag,'Custom/Marks/RecStart')) 
            metadata.RecOnevents{p} = obj.level1StudyObj.eventCodesInfo(p).code;
        end

        if any(strfind(obj.level1StudyObj.eventCodesInfo(p).condition.tag,'Custom/Marks/RecStop'))
            metadata.RecOffevents{p} = obj.level1StudyObj.eventCodesInfo(p).code;
        end

        if any(strfind(obj.level1StudyObj.eventCodesInfo(p).condition.tag,'Custom/Marks/In'))
            metadata.RecOffevents{p} = obj.level1StudyObj.eventCodesInfo(p).code;
        end
    end

    % Clear empties compact the cell array
    metadata.RecOnevents = metadata.RecOnevents(~cellfun(@isempty, metadata.RecOnevents));
    metadata.RecOffevents = metadata.RecOffevents(~cellfun(@isempty, metadata.RecOffevents));

    % Check On Off events are listed in pairs
    if length(metadata.RecOnevents) ~= length(metadata.RecOffevents)
        error('WARNING: Your start and stop events are not in pairs!')
    end

    % Set Event Method to OnOff
    if ~isempty(metadata.RecOnevents) && ~isempty(metadata.RecOffevents)
        metadata.RecOnEventRecOffEvent = 1;    %Marks Between
        metadata.InTaskOutTask = 0;            %Marks Around
    end

    % Set Event Method to In
    if ~isempty(metadata.Inevents)
        metadata.RecOnEventRecOffEvent = 0;    %Marks Between
        metadata.InTaskOutTask = 1;            %Marks Around
    end
end
%% EVENTS - Events Renamed to On/Off or In
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This section checks the if any events were renamed to On/Off/In 
% It also indicates with a 0,1 on what method is being used.

% Starts if no file and nothing found yet
if ((metadata.InTaskOutTask == 0) && (metadata.RecOnEventRecOffEvent == 0)) && (metadata.efile == 0)
    % Look for renamed events that match
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    if ~isempty(find(ismember(metadata.erename,'RecStart'))) && ~isempty(find(ismember(metadata.erename,'RecStop')))
        warning('You renamed your events to RecStart and Recstop!');
        
        if length(metadata.RecOnevents) ~= length(metadata.RecOffevents)
            error('WARNING: Your start and stop events are not in pairs!')
        end

        % Set Event Method to OnOff
        if ~isempty(metadata.RecOnevents) && ~isempty(metadata.RecOffevents)
            metadata.RecOnEventRecOffEvent = 1;    %Marks Between
            metadata.InTaskOutTask = 0;            %Marks Around
        end
    end

    % Look for renamed events that match
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    if  ~isempty(find(ismember(metadata.erename,'InEvent')))
        warning('You renamed your events to InEvent!');
        % Set Event Method to In
        if ~isempty(metadata.Inevents)
            metadata.RecOnEventRecOffEvent = 0;    %Marks Between
            metadata.InTaskOutTask = 1;            %Marks Around
        end
    end
end
%% EVENTS - Config On/Off or In
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This section checks the configs for events that can be considered On/Off/In and saves them in the On/Off/In cell array.
% It also indicates with a 0,1 on what method is being used.

% Look equivilencies for On/Off events denoted in configs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Starts if no file and nothing found yet
if ((metadata.InTaskOutTask == 0) && (metadata.RecOnEventRecOffEvent == 0)) && (metadata.efile == 0)
    try
        % From Batch string swap
        metadata.RecOnevents = {[Onevents]}; 
        if ~isempty(metadata.RecOnevents)
            logging_log('INFO', 'Found Onevents described in batch config');
        end
    catch
        logging_log('INFO', 'No Onevents loaded into batch config');
    end

    try
        % From Batch string swap
        metadata.RecOffevents = {[Offevents]}; 
        if ~isempty(metadata.RecOffevents)
            logging_log('INFO', 'Found Offevents described in batch config');
        end
    catch
        logging_log('INFO', 'No Offevents loaded into batch config');
    end
    
    % Double empty wont set this off
    if length(metadata.RecOnevents) ~= length(metadata.RecOffevents)
        error('WARNING: Your start and stop events are not in pairs!')
    end

    % Set Event Method to OnOff
    if ~isempty(metadata.RecOnevents) && ~isempty(metadata.RecOffevents)
        metadata.RecOnEventRecOffEvent = 1;    %Marks Between
        metadata.InTaskOutTask = 0;            %Marks Around
    end

% Look equivilencies for In events denoted in configs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    try
        % From Batch string swap
        metadata.Inevents = {[Inevents]}; 
        if ~isempty(metadata.Inevents')
            logging_log('INFO', 'Found Inevents described in batch config');
        end
    catch
        logging_log('INFO', 'No Inevents loaded into batch config');
    end

    % Set Event Method to In
    if ~isempty(metadata.Inevents)
        metadata.RecOnEventRecOffEvent = 0;    %Marks Between
        metadata.InTaskOutTask = 1;            %Marks Around
    end
end
%% EVENTS - Manual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Gives the opertunity to type in the On/Off/In events. Or they can open
% the vised edit plot with the current events and place their own on/off
% where ever they would like. Doesnt allow for In Events at the moment.

% If nothing can be found in HED Config
if ((metadata.InTaskOutTask == 0) && (metadata.RecOnEventRecOffEvent == 0)) && (metadata.efile == 0) 
    % Starts if no file and nothing found yet
    logging_log('INFO', 'Please Follow GUI Instructions...');
    results=inputgui( ...
            {1 1 1 1 1 1 1 1 1 1 1 1 1 1 [3 1]}, ...
            {...
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string', 'Choose the Method in which you would like to denote the InTask/Out Task Time:'}, ...
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string', 'Method 1: List Events that should be treated as On/Off where On means the task is starting'}, ...
            {'Style', 'text', 'string', '      List the On Event Types as Strings. (ie. ''1'' , ''Go'' , ''Sample'') '}, ...
            {'Style', 'edit', 'string', '', 'tag', 'edt_fl'}, ... 
            {'Style', 'text', 'string', '      List the Off Event Type as Strings. (ie. ''2'' , ''NoGo'' , ''999'')  where 2 is the stop of 1'}, ...
            {'Style', 'edit', 'string', '', 'tag', 'edt_fl'}, ... 
            {'Style', 'text', 'string', 'Make sure this the On/Off list are the same size!'}, ...
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string', 'Method 2: List Events that are in task.'}, ...
            {'Style', 'text', 'string', '      Data will be marked as out of task if it is not in proximity of these. (ie. ''3'' , ''4'')'}, ...
            {'Style', 'edit', 'string', '', 'tag', 'edt_fl'}, ... 
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string', 'Method 3: Manually scroll through data and place RecordOn/RecordOff Events.'}, ...
            {'Style','checkbox','string','Manual Mode On','value',0}, ... 
            }, ...
            'pophelp(''StudyBuddy'');', 'Decide on how you will mark In/Out of Task Time' ...
            );

    % Cancelled
    if isempty(results);return;end
    
    % Chose to do On/Off
    if ~isempty(results{1})
        % Set Event Method to OnOff
        metadata.RecOnevents = eval(['{',results{1},'};']);
        metadata.RecOnEventRecOffEvent = 1;    %Marks Between
        metadata.InTaskOutTask = 0;            %Marks Around
    end
    
    if ~isempty(results{2})
        metadata.RecOffevents = eval(['{',results{2},'};']);
    end
    
    % Chose to do In
    if ~isempty(results{3})
        metadata.Inevents = eval(['{',results{3},'};']);
        % Set Event Method to In
        metadata.RecOnEventRecOffEvent = 0;    %Marks Between
        metadata.InTaskOutTask = 1;            %Marks Around
    end
    
    % Chose to do Manual OnOff - Instruction GUI
    if results{4}==1;
         logging_log('INFO', 'Please Follow GUI Instructions...');
            results=inputgui( ...
            {1 1 1 1 1 1}, ...
            {...
            {'Style', 'text', 'string',blanks(100)}, ...
            {'Style', 'text', 'string', 'You have selected to do task time manually'}, ...
            {'Style', 'text', 'string', 'In the next pop up please using the following controls then press Update EEG Structure'}, ...
            {'Style', 'text', 'string', '       Press ''a'' to place a Recording Start Mark'}, ...
            {'Style', 'text', 'string', '       Press ''b'' to place a Recording Stop Mark'}, ...
            {'Style', 'text', 'string', 'Make sure you have a matching number of starts and stops placed around your tasks!'}, ...
            }, ...
            'pophelp(''StudyBuddy'');', 'Entering Manual Vised Marks' ...
            );
        
        % Set Event Method to OnOff
        metadata.RecOnEventRecOffEvent = 1;    %Marks Between
        metadata.InTaskOutTask = 0;            %Marks Around
        
        % Plot
        metadata.tally = length(EEG.event);
        set(0, 'DefaultFigureRenderer','OpenGl');
        logging_log('INFO', 'Please Follow GUI Instructions...');
        EEG = pop_vised(EEG,'data_type','EEG','pop_gui','off','keyselectcommand',{'a,ve_edit(''qem'',''RecStart'')' , 'b,ve_edit(''qem'',''RecStop'')'},'title','Record your Task Start and Task Stop Marks','winlength',50);
        uiwait;
        metadata.ManualMarks = 1;   
        
        % Check for equal numbers of Start and Stop
        % Can have start1 start2 stop1 stop2
        logging_log('INFO', 'Identifying New Events');
        for h = 1:(length(EEG.event))
            if strcmp(EEG.event(h).type,'RecStart')
                metadata.tallya = metadata.tallya + 1;  
            elseif strcmp(EEG.event(h).type,'RecStop')
                metadata.tallyb = metadata.tallyb + 1; %ToDo: simply the loop
            end
        end
    end
end
%% EVENTS - Create Events
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create new EEG.event with new events at the indicated equivalent
% Manual has already updated EEG.event. Tallies record the number of new
% events that are being made to check for interval consistancy

tic;
if metadata.ManualMarks == 0
    logging_log('INFO', 'Creating new events to stake out marked time sections');
    for i=1:length(EEG.event);                              % ToDo: simplfy this loop
        metadata.nbevents = length(EEG.event);
        for a = 1:length(metadata.RecOnevents)
            if strcmp(EEG.event(i).type,metadata.RecOnevents{a})
               EEG.event(1 + metadata.nbevents).type = 'RecStart';
               EEG.event(1 + metadata.nbevents).latency = EEG.event(i).latency;
               EEG.event(1 + metadata.nbevents).urevent = (1 + metadata.nbevents);
               EEG.event(1 + metadata.nbevents).duration = 0;
               metadata.tallya = metadata.tallya + 1;
            end
        end

        for b = 1:length(metadata.RecOffevents)
            if strcmp(EEG.event(i).type,metadata.RecOffevents{b})
               EEG.event(1 + metadata.nbevents).type = 'RecStop';
               EEG.event(1 + metadata.nbevents).latency = EEG.event(i).latency;
               EEG.event(1 + metadata.nbevents).urevent = (1 + metadata.nbevents);
               EEG.event(1 + metadata.nbevents).duration = 0;
               metadata.tallyb = metadata.tallyb + 1;
            end
        end

        for c = 1:length(metadata.Inevents)
           if  strcmp(EEG.event(i).type,metadata.Inevents{c})
               EEG.event(1 + metadata.nbevents).type = 'InEvent';
               EEG.event(1 + metadata.nbevents).latency = EEG.event(i).latency;
               EEG.event(1 + metadata.nbevents).urevent = (1 + metadata.nbevents);
               EEG.event(1 + metadata.nbevents).duration = 0;
               % Just for reference tally c doesnt have to match anything
               metadata.tallyc = metadata.tallyc + 1;
           end
        end
    end
end
logging_log('INFO', ['Creating new ' num2str(metadata.tallya + metadata.tallyb + metadata.tallyc) ' events took: ' num2str(toc) 'sec.']);
%% EVENTS - Save or Load Events File
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% If no file exists this funtion will write what was just made to file. If a
% file does exist the script will have jumpped to here to load it.

if metadata.efile == 0
    logging_log('INFO', 'Saving Events File - This will take a minute...');
    eeg_eventtable(EEG,'exportFile',metadata.efnp_marks,'dispTable',0); 
end

if metadata.efile == 1
   warning('Loading Events File: this may take a while based on the number of events you have!');
   tic;
   EEG.event = importevent(metadata.efnp_marks,[],metadata.change_srate,'fields',{'latency','type'}); %??????????????????????????????????LOADTIME
   warning(['Loading Events File took: ' num2str(toc) 'sec.']);
   error('WARNING:Loading events does not work at the moment 3/8/2017, delete are rerun');
end

% At this point all of the events exist in the file. The next sections will
% make the flags marks that go around or between these.
%% REF - CAN PROBABLY BE TAKEN OUT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Saves a key/legend that has the names of the old events and the new names
% of the events, for reference.
% % % if metadata.efile == 0
% % %     tic;
% % %     %File name to save good for ESS and OTHER 
% % %     keyfile = fopen([metadata.dfnp(1:end-4) '_mark_events_key.txt' ],'w');
% % % 
% % % 
% % %     fprintf(keyfile,['File Name: ' '[batch_dfn]' '\n']);
% % %     try
% % %         fprintf(keyfile,['Events File Name: ' metadata.efnp_marks '\n\n']);
% % %     catch
% % %         fprintf(keyfile,['Events File Name: None \n\n']);
% % %     end
% % %     
% % % 
% % %     formatting = '\t%s\t\t\t\t%s\n';
% % %     for i = 1:metadata.merges
% % %         fprintf(keyfile,['\nMerged File Number: ' num2str(i) '\n']);
% % %         fprintf(keyfile,['-------------------------------------------' '\n']);
% % %         fprintf(keyfile,'Old Event Name    New Event Name \n');
% % %         fprintf(keyfile,formatting, metadata.erename{i,1:metadata.nume(i)});
% % %     end
% % % 
% % %     fprintf(keyfile,['\nAdded Events: ']);
% % %     fprintf(keyfile,['\n-------------------------------------------\n']);
% % % 
% % %     try
% % %         for i  = 1: length(metadata.Onevents)
% % %             fprintf(keyfile,['\nMark On Off Pairs created at events: ' '\n']);
% % %          fprintf(keyfile,'%s\n',[ metadata.RecOnevents{i} ]);
% % %          fprintf(keyfile,'%s\n',[ metadata.RecOffevents{i} ]);
% % %         end
% % %     catch
% % %     end
% % %     try
% % %         for i  = 1: length(metadata.Inevents)
% % %          fprintf(keyfile,['\nMark InEvents created at events: ' '\n']);
% % %          fprintf(keyfile,'%s\n',[ metadata.Inevents{i} ]);
% % %         end
% % %     catch
% % %     end
% % % 
% % %     % Config Example for reference, uses the cell 'placeholder' for empties must same size
% % %     % metadata.erename = file1    { 'Type#' 'TypeReName' 'Type#' 'TypeReName' 'Type#' 'TypeReName' ;
% % %     %                    file2      'Type#' 'TypeReName' 'Type#' 'TypeReName' 'Type#' 'TypeReName' ;
% % %     %                    file3      'Type#' 'TypeReName' 'Type#' 'TypeReName' 'Type#' 'TypeReName' ;
% % %     %                    file4      'Type#' 'TypeReName' 'Type#' 'TypeReName' 'placeholder' 'placeholder' ;}
% % % 
% % %     logging_log('INFO', ['Saving Event Key File took: ' num2str(toc) 'sec.']);
% % % end
%% EVENTS - Use On and Off Events to make Marks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% All the required events will be in the file by now. Checks for interval
% consistency then creates marks.

% May have this event type if loaded
if metadata.efile == 1
    metadata.RecOnEventRecOffEvent = 1;    %Marks Between
end

if metadata.RecOnEventRecOffEvent == 1  
   % ManualConfig/Manual/Config/ESS/Rename
   logging_log('INFO', 'Building Out-Task Marks.');  
   %Check Intervals
   logging_log('INFO', 'Checking for Event Interval Consistency');  
   if metadata.tallya ~= metadata.tallyb
       logging_log('INFO', ['On Events Total:' num2str(metadata.tallya) ]);
       logging_log('INFO', ['Off Events Total:' num2str(metadata.tallyb) ]);
       error('WARNING: You have an uneven amount of On and Off Events! Can not make interval marks.')
   end
 
   % Mark inverted gaps to be out of task
   try
       EEG = pop_marks_event_gap(EEG,{'RecStart','RecStop'},4000,'out_task',[0.1 0.1 0.1], ...
            'interval','on', ... 
            'critdir','max', ...
            'exact','off', ...
            'ref_point','both', ...
            'invert_flags','on'); 
    catch
        warning('Caution: No Onevents/Offevents Found!');
    end    
           
end
%% EVENTS - Use In Events to make Marks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% All the required events will be in the file by now. Creates marks.

% May have this event type if loaded
if metadata.efile == 1
    metadata.InTaskOutTask = 1;            %Marks Around
end

if metadata.InTaskOutTask == 1
    logging_log('INFO', 'Building Out-Task Marks.');  
    % ManualConfig/Config/Rename
    try
    % In Task
    EEG = pop_marks_event_gap(EEG,{'InEvent'},4000,'out_task',[0.1 0.1 0.1], ...
                    'interval','off', ...
                    'critdir','max', ...
                    'exact','off', ...
                    'offsets',[3000 -3000], ...
                    'ref_point','both', ...
                    'invert_flags','off');  
    catch
        warning('Caution: No Inevents Found!');
    end                    
end
%% EVENTS -Additional Marks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% These are some additional marks to clean up the Task time marks by
% marking small gaps less than 2 seconds between out task as also out task.
% This way the data is in resonably sized blocks.

logging_log('INFO', 'Building Mark Gap Marks');  
% Mark flag gaps <2 sec and Combined marks into manual
    try
        EEG=pop_marks_flag_gap(EEG,{'manual','out_task'},2000,'mark_gap',[.2,.2,.2],'offsets',[0 0],'ref_point','both');
        EEG=pop_marks_merge_labels(EEG,'time_info',{'manual','mark_gap','out_task'},'target_label','manual');
    catch
        error('WARNING: No Task marks were found! Likley culprits are config events On/Off or In, srate, or bad existing file.')
    end
%% LOAD - Save the init file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
try
    metadata.filerename = '[filerename]';
    if isempty(metadata.filerename)
        metadata.filerename = '[filerename]';
    end
catch
    metadata.filerename = '[filerename]';
end

EEG = pop_saveset( EEG, 'filename',metadata.filerename,'filepath','analysis/data/1_init/');
EEG = eeg_checkset( EEG );
logging_log('INFO', '******************INIT COMPLETE - READY FOR PIPELINE*******************');  













